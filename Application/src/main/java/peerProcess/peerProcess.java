/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package peerProcess;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.lang.Thread;
import java.util.concurrent.atomic.AtomicBoolean;

public class peerProcess {

    private final String    ConfigFileName  = "Common.cfg";
    private final String    PeerInfoFile    = "PeerInfo.cfg";

    private int             PreferredNeighbourCount;
    private int             UnchockingInterval;
    private int             OptimisticUnchokingInterval;
    private String          FileName;
    private int             FileSize;
    private int             PieceSize;
    private AtomicBoolean   TaskComplete;
    private int             MyPeerId;

    static LinkedHashMap <Integer, PeerConfigurationData> PeerMap;

    class PeerConfigurationData {
        Integer     PeerId;
        String      HostName;
        int         PortNumber;
        boolean     HasFile;
        boolean     HasFullFile;
        byte[]      FileState = null;
    }

    private peerProcess (int pPeerId) {

        FileSize    = 0;
        PieceSize   = 0;
        MyPeerId    = pPeerId;
        FileName    = null;

        TaskComplete    = new AtomicBoolean(false);

        OptimisticUnchokingInterval = 0;
        UnchockingInterval          = 0;
        PreferredNeighbourCount     = 0;

        PeerMap = new LinkedHashMap <Integer, PeerConfigurationData>();
    }

    private boolean Initialize () {

        if (!ReadConfigurations())
            return false;

        if (Logger.GetLogger().Initialize(MyPeerId) != eLoggerErrors.E_LE_SUCCESS)
            return false;

        Logger.GetLogger().Log ("Program start time: " + new SimpleDateFormat ("mm/dd/yyyy HH:mm:ss").format ((Calendar.getInstance().getTime())));

        return true;
    }

    private static boolean CheckFileIsMissing (String pFileName){

        if (Files.notExists(Paths.get (pFileName))){
            System.out.println ("Missing file: \"" + pFileName + "\" at location: \"" + Paths.get(".").toAbsolutePath().toString() + "\"");
            return true;
        }

        return false;
    }

    private boolean ValidateConfigFileData ()
    {
        // validate the configurations
        if (PreferredNeighbourCount < 1 || UnchockingInterval < 1 || OptimisticUnchokingInterval < 1 || FileSize < 1 || PieceSize < 1) {

            System.out.println("One of the configuration is file \"" + ConfigFileName + "\" is incorrect.");
            return false;
        }

        if (CheckFileIsMissing(FileName)) {

            System.out.println("The file: \"" + FileName + "\" specified in the configuration does not exists.");
            return false;
        }

        /*if (Files.size(Paths.get(FileName)) != FileSize){

            System.out.println ("The file size specified in configuration and size of actual file does not match.");
            return false;
        }*/

        return true;
    }

    private boolean ReadConfigFile ()
    {
        Scanner     fileScanner;
        String      configLabel;

        try {
            fileScanner = new Scanner(Paths.get(ConfigFileName));

            while (fileScanner.hasNext()) {

                configLabel = fileScanner.next();

                // updating the relevant configuration based on the config label
                switch (configLabel) {
                    case "NumberOfPreferredNeighbors":
                        PreferredNeighbourCount = fileScanner.nextInt();
                        break;

                    case "UnchokingInterval":
                        UnchockingInterval = fileScanner.nextInt();
                        break;

                    case "OptimisticUnchokingInterval":
                        OptimisticUnchokingInterval = fileScanner.nextInt();
                        break;

                    case "FileName":
                        FileName = fileScanner.next();
                        break;

                    case "FileSize":
                        FileSize = fileScanner.nextInt();
                        break;

                    case "PieceSize":
                        PieceSize = fileScanner.nextInt();
                        break;

                    default:
                        System.out.println("Invalid configuration value: " + configLabel);
                        return false;
                }
            }
        }
        catch (IOException ex){
            System.out.println ("Unable to open configuration file : \"" + ConfigFileName + "\".");
            System.out.println (ex.getMessage());
            return false;
        }

        return ValidateConfigFileData();
    }

    private boolean ReadPeerFile (){

        Scanner     fileScanner;

        try {

            fileScanner   = new Scanner(Paths.get (PeerInfoFile));

            while (fileScanner.hasNext()){

                int     arraySize;
                int     pktCount;

                PeerConfigurationData peerData = new PeerConfigurationData();

                peerData.PeerId     = fileScanner.nextInt();
                peerData.HostName   = fileScanner.next();
                peerData.PortNumber = fileScanner.nextInt();
                peerData.HasFile    = (fileScanner.nextInt() == 1);

                pktCount    = FileSize/PieceSize + ((FileSize%PieceSize > 0)?1:0);
                arraySize   = pktCount/Byte.SIZE + ((pktCount%Byte.SIZE > 0)?1:0);

                peerData.FileState  = new byte[arraySize];

                for (int iter = 0; iter < arraySize; iter++){

                    // if the application has full file it will initialize its file state as all bit set to 1
                    if(peerData.PeerId == MyPeerId && peerData.HasFile) {
                        peerData.FileState[iter] = -1;
                        peerData.HasFullFile     = true;
                    }
                    else {// the value is yer to be discovered by the application protocol
                        peerData.FileState[iter] = 0;
                        peerData.HasFullFile = false;
                    }
                }

                // adding the peer information to a list fou later use
                PeerMap.put(peerData.PeerId, peerData);
            }
        }
        catch (IOException ex){
            System.out.println ("Unable to open the configuration file: \"" + PeerInfoFile +"\".");
            System.out.println (ex.getMessage());
            return false;
        }

        return true;
    }

    /**
     * Reads both the configuration files and populates the app variables.
     *
     * @return true when the configurations are successfully read and false otherwise.
     */
    private boolean ReadConfigurations () {

        if (CheckFileIsMissing (ConfigFileName))
            return false;

        if (CheckFileIsMissing(PeerInfoFile))
            return false;

        return ReadConfigFile() && ReadPeerFile();
    }

    public static void main(String[] args) {

        peerProcess     myApp = new peerProcess(Integer.parseInt(args[0]));

        if (!myApp.Initialize())
            return;

        //the application can go multithreaded beyond this point
        myApp.Execute ();

        myApp.CleanUp();
    }

    private void CleanUp ()
    {
        Logger.GetLogger().Log ("Program termination time: " + new SimpleDateFormat ("mm/dd/yyyy HH:mm:ss").format ((Calendar.getInstance().getTime())));
        Logger.GetLogger().Close ();
    }

    /**
     * The function checks if all the peers have got the full file
     *
     * @return true if all peers have full file, else false
     */
    private boolean AllPeersHaveFile (){

        for (Map.Entry<Integer, PeerConfigurationData> mapPair : PeerMap.entrySet()) {

            // if any of the peer does not have full file return false
            if (!mapPair.getValue().HasFile)
                return false;
        }

        return true;
    }

    private boolean ConnectToKnownHosts()
    {
        Iterator    iter = PeerMap.entrySet().iterator();
        Socket      newSocket;
        Thread      newThread;

        while (iter.hasNext()){

            Map.Entry  mapPair = (Map.Entry)iter.next();

            // the other socket after this are responsible for initiating connect to this instance
            if (((PeerConfigurationData)mapPair.getValue()).PeerId == MyPeerId)
                break;

            try {
                newSocket = new Socket(InetAddress.getByName(((PeerConfigurationData) mapPair.getValue()).HostName), ((PeerConfigurationData) mapPair.getValue()).PortNumber);

                newThread = new AppController (newSocket, MyPeerId);

                // thread is marked as daemon. Only the main thread is non daemon. But is blocked for all task to complete. If all task is complete we quit :)
                newThread.setDaemon(true);

                newThread.start();
            }
            catch (IOException ex){
                System.out.println ("*******************EXCEPTION*******************");
                System.out.println ("IOException occurred while creating socket.");
                System.out.println (ex.getMessage());
            }

        }

        return true;
    }

    /**
     * Initiates all the helping threads needed by the application
     *
     * <p>
     *     To keep the wait time on the server thread minimum we are spawning other threads to perform other routine maintenance work
     * </p>
     */
    private void InitiateCompletionWait ()
    {
        while (true){

            try {
                Thread.sleep(2000);
            }
            catch (InterruptedException ex) {
                System.out.println ("*******************EXCEPTION*******************");
                System.out.println ("IOException occurred while checking for task completion.");
                System.out.println (ex.getMessage());
            }

            if (AllPeersHaveFile()){
                TaskComplete.set (true);
                break;
            }
        }
    }

    /**
     * The actual operations starts here
     */
    private void Execute ()
    {
        Runnable    listenerTask;
        Thread      listenerThread;

        listenerTask = new Runnable() {

            public void run() {
                Thread      noob;

                try {
                    ServerSocket    listeningSocket;
                    listeningSocket = new ServerSocket(PeerMap.get(MyPeerId).PortNumber);

                    // the server would keep listening
                    while (!TaskComplete.get()){

                        noob = new AppController (listeningSocket.accept(), MyPeerId);

                        noob.setDaemon(true);

                        noob.start();
                    }
                }
                catch (IOException ex){
                    System.out.println ("*******************EXCEPTION*******************");
                    System.out.println ("IOException occurred while closing a connection.");
                    System.out.println (ex.getMessage());
                }
            }
        };

        listenerThread = new Thread(listenerTask, "peerProcessListner");

        // listener thread is marked as daemon as if the main thread exits all task is complete so all threads except main thread are marked daemon
        listenerThread.setDaemon(true);

        listenerThread.start();

        if (!ConnectToKnownHosts())
            return;

        // wait till the task is actually completed i.e all peers have full file
        InitiateCompletionWait ();
    }
}
