/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package peerProcess;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class peerProcess {

    private final String    ConfigFileName  = "Common.cfg";
    private final String    PeerInfoFile    = "PeerInfo.cfg";

    private int             PreferredNeighbourCount;
    private int             UnchockingInterval;
    private int             OptimisticUnchokingInterval;
    private String          FileName;
    private int             FileSize;
    private int             PieceSize;
    private AtomicBoolean   TaskComplete;
    private int             MyPeerId;

    private LinkedHashMap <Integer, PeerConfigurationData> PeerMap;

    class PeerConfigurationData {
        Integer     PeerId;
        String      HostName;
        int         PortNumber;
        boolean     HasFile;
        boolean     HasFullFile;
        int[]       FileState = null;
    }

    private peerProcess (int pPeerId) {

        FileSize    = 0;
        PieceSize   = 0;
        MyPeerId    = pPeerId;
        FileName    = null;

        TaskComplete    = new AtomicBoolean(false);

        OptimisticUnchokingInterval = 0;
        UnchockingInterval          = 0;
        PreferredNeighbourCount     = 0;

        PeerMap = new LinkedHashMap <Integer, PeerConfigurationData>();
    }

    private boolean Initialize () {

        if (!ReadConfigurations())
            return false;

        if (Logger.GetLogger().Initialize(MyPeerId) != eLoggerErrors.E_LE_SUCCESS)
            return false;

        Logger.GetLogger().Log ("Program start time: " + new SimpleDateFormat ("mm/dd/yyyy HH:mm:ss").format ((Calendar.getInstance().getTime())));

        return true;
    }

    /**
     * Reads both the configuration files and populates the app variables.
     *
     * @return true when the configurations are successfully read and false otherwise.
     */
    private boolean ReadConfigurations () {

        Scanner     fileScanner;
        String      configLabel;

        if (Files.notExists(Paths.get (ConfigFileName))){
            System.out.println ("Missing file: \"" + ConfigFileName + "\" at location: \"" + Paths.get(".").toAbsolutePath().toString() + "\"");
            return false;
        }

        if (Files.notExists(Paths.get (PeerInfoFile))){
            System.out.println ("Missing file: \"" + PeerInfoFile + "\" at location: \"" + Paths.get(".").toAbsolutePath().toString() + "\"");
            return false;
        }

        try {
            fileScanner = new Scanner(Paths.get (ConfigFileName));

            while (fileScanner.hasNext()) {

                configLabel = fileScanner.next();

                // updating the relevant configuration based on the config label
                switch (configLabel){
                    case "NumberOfPreferredNeighbors":
                        PreferredNeighbourCount = fileScanner.nextInt();
                        break;

                    case "UnchokingInterval":
                        UnchockingInterval = fileScanner.nextInt();
                        break;

                    case "OptimisticUnchokingInterval":
                        OptimisticUnchokingInterval = fileScanner.nextInt();
                        break;

                    case "FileName":
                        FileName = fileScanner.next();
                        break;

                    case "FileSize":
                        FileSize = fileScanner.nextInt();
                        break;

                    case "PieceSize":
                        PieceSize = fileScanner.nextInt();
                        break;

                    default:
                        System.out.println("Invalid configuration value: " + configLabel);
                        return false;


                }
            }

            // validate the configurations
            if (PreferredNeighbourCount < 1 || UnchockingInterval < 1 || OptimisticUnchokingInterval < 1 || FileSize < 1 || PieceSize < 1){

                System.out.println ("One of the configuration is file \"" + ConfigFileName +"\" is incorrect.");
                return false;
            }

            if (FileName == null || Files.notExists(Paths.get(FileName))){

                System.out.println ("The file: \""+ FileName + "\" specified in the configuration does not exists.");
                return false;
            }

            /*if (Files.size(Paths.get(FileName)) != FileSize){

                System.out.println ("The file size specified in configuration and size of actual file does not match.");
                return false;
            }*/

            fileScanner   = new Scanner(Paths.get (PeerInfoFile));

            while (fileScanner.hasNext()){

                int     arraySize;
                int     pktCount;

                PeerConfigurationData peerData = new PeerConfigurationData();

                peerData.PeerId     = fileScanner.nextInt();
                peerData.HostName   = fileScanner.next();
                peerData.PortNumber = fileScanner.nextInt();
                peerData.HasFile    = (fileScanner.nextInt() == 1);

                pktCount = FileSize/PieceSize + ((FileSize%PieceSize > 0)?1:0);
                arraySize = pktCount/Integer.SIZE + ((pktCount%Integer.SIZE > 0)?1:0);

                peerData.FileState  = new int[arraySize];

                for (int iter = 0; iter < arraySize; iter++){

                    // if the application has full file it will initialize its file state as all bit set to 1
                    if(peerData.PeerId == MyPeerId && peerData.HasFile) {
                        peerData.FileState[iter] = -1;
                        peerData.HasFullFile     = true;
                    }
                    else {// the value is yer to be discovered by the application protocol
                        peerData.FileState[iter] = 0;
                        peerData.HasFullFile = false;
                    }
                }

                // adding the peer information to a list fou later use
                PeerMap.put(peerData.PeerId, peerData);
            }
        }
        catch (FileNotFoundException ex){
            System.out.println ("One of the configuration file is missing.");
            System.out.println (ex.getMessage());
            return false;
        }
        catch (Exception ex){
            System.out.println ("Error in parsing one of the configuration file.");
            System.out.println (ex.getMessage());
            return false;
        }

        return true;
    }

    public static void main(String[] args) {

        peerProcess     myApp = new peerProcess(Integer.parseInt(args[0]));

        if (!myApp.Initialize())
            return;

        //the application can go multithreaded beyond this point
        myApp.Execute ();

        myApp.CleanUp();
    }

    private void CleanUp ()
    {
        Logger.GetLogger().Log ("Program termination time: " + new SimpleDateFormat ("mm/dd/yyyy HH:mm:ss").format ((Calendar.getInstance().getTime())));
        Logger.GetLogger().Close ();
    }

    /**
     * The function checks if all the peers have got the full file
     *
     * @return true if all peers have full file, else false
     */
    public boolean AllPeersHaveFile (){

        Iterator iter = PeerMap.entrySet().iterator();

        while (iter.hasNext()){

            Map.Entry  mapPair = (Map.Entry)iter.next();

            // if any of the peer does not have full file return false
            if (((PeerConfigurationData)mapPair.getValue()).HasFile == false)
                return  false;
        }

        return true;
    }

    public boolean ConnectToKnownHosts()
    {
        Iterator    iter = PeerMap.entrySet().iterator();
        Socket      newSocket;

        while (iter.hasNext()){

            Map.Entry  mapPair = (Map.Entry)iter.next();

            // the other socket after this are responsible for initiating connect to this instance
            if (((PeerConfigurationData)mapPair.getValue()).PeerId == MyPeerId)
                break;

            try {
                newSocket = new Socket(InetAddress.getByName(((PeerConfigurationData) mapPair.getValue()).HostName), ((PeerConfigurationData) mapPair.getValue()).PortNumber);
                new AppController (newSocket).start();

            }
            catch (IOException ex){
                System.out.println ("*******************EXCEPTION*******************");
                System.out.println ("IOException occurred while creating socket.");
                System.out.println (ex.getMessage());
            }

        }

        return true;
    }

    /**
     * Initiates all the helping threads needed by the application
     *
     * <p>
     *     To keep the wait time on the server thread minimum we are spawning other threads to perform other routine maintenance work
     * </p>
     *
     * @return true on success and false on failure
     */
    private boolean InitiateHelperThreads ()
    {
        Runnable routineCheck;

        if (ConnectToKnownHosts()== false)
            return false;

        routineCheck = new Runnable() {
            @Override
            public void run() {

                while (true){

                    try {
                        Thread.sleep(2000);
                    }
                    catch (InterruptedException ex)
                    {
                        System.out.println ("*******************EXCEPTION*******************");
                        System.out.println ("IOException occurred while checking for task completion.");
                        System.out.println (ex.getMessage());
                        break;
                    }

                    if (AllPeersHaveFile()){
                        TaskComplete.set (true);
                        break;
                    }
                }
            }
        };

        new Thread(routineCheck).start();

        return true;
    }

    /**
     * The actual operations starts here
     */
    private void Execute ()
    {
        ServerSocket    listeningSocket;
        Socket          newConn;

        if (!InitiateHelperThreads ())
            return;

        try {
            listeningSocket = new ServerSocket(PeerMap.get(MyPeerId).PortNumber);

            // the server would keep listening
            while (true){
                new AppController (listeningSocket.accept()).start();

                if(TaskComplete.get())
                    break;
            }
        }
        catch (IOException ex){
            System.out.println ("*******************EXCEPTION*******************");
            System.out.println ("IOException occurred while closing a connection.");
            System.out.println (ex.getMessage());
            return;
        }
    }
}
