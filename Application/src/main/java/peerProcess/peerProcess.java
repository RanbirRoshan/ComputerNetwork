/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package peerProcess;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.lang.Thread;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerArray;

public class peerProcess {

    private static final boolean InDebug = true;

    private final String ConfigFileName = "Common.cfg";
    private final String PeerInfoFile = "PeerInfo.cfg";

    private int PreferredNeighbourCount;
    private int UnchockingInterval;
    private int OptimisticUnchokingInterval;
    static String FileName;
    private RandomAccessFile DatFile;
    private int FileSize;
    static int PieceSize;
    private AtomicBoolean TaskComplete;
    private int MyPeerId;
    static final int BitPerBufVal = Integer.SIZE;
    private BroadcastStruct HaveBroadCastList;
    private long LastChokeUpdateTime;
    private long LastOptimisticUnchokingIntervalUpdateTime;
    private int OptUnchokedPeerId;

    static LinkedHashMap<Integer, PeerConfigurationData> PeerMap;

    class PeerConfigurationData {
        Integer PeerId;
        String HostName;
        int PortNumber;
        int NumPiecesAvailable;
        boolean HasFile;
        boolean HasFullFile;
        AtomicIntegerArray FileState = null;
        AtomicBoolean IsChocked = new AtomicBoolean();
        AtomicBoolean SendChokeInfo = new AtomicBoolean();
        AtomicBoolean IsInterested = new AtomicBoolean(false);
        AtomicIntegerArray RequestedFileState = null;
        AtomicInteger ReceivedPiecesCount = new AtomicInteger(0);
        Boolean IsChokedByPeer = false;
    }

    private peerProcess(int pPeerId) {

        FileSize = 0;
        PieceSize = 0;
        MyPeerId = pPeerId;
        FileName = null;

        TaskComplete = new AtomicBoolean(false);
        HaveBroadCastList = new BroadcastStruct();
        OptUnchokedPeerId = -1;

        // adding a dummy list for everyone to have an initial list to start with if we
        // dont have it we will land into
        // trouble as the threads that start at same time with no initial input will not
        // know the first broadcast message
        HaveBroadCastList.AddForBroadcast((byte) -1, null);

        LastChokeUpdateTime = 0;
        LastOptimisticUnchokingIntervalUpdateTime = 0;

        OptimisticUnchokingInterval = 0;
        UnchockingInterval = 0;
        PreferredNeighbourCount = 0;

        PeerMap = new LinkedHashMap<Integer, PeerConfigurationData>();
    }

    private boolean Initialize() {

        if (!ReadConfigurations())
            return false;

        if (Logger.GetLogger().Initialize(MyPeerId) != eLoggerErrors.E_LE_SUCCESS)
            return false;

        Logger.GetLogger().Log("Program start time: "
                + new SimpleDateFormat("mm/dd/yyyy HH:mm:ss").format((Calendar.getInstance().getTime())));

        return true;
    }

    private static boolean CheckFileIsMissing(String pFileName) {

        if (Files.notExists(Paths.get(pFileName))) {
            System.out.println("Missing file: \"" + pFileName + "\" at location: \""
                    + Paths.get(".").toAbsolutePath().toString() + "\"");
            return true;
        }

        return false;
    }

    private boolean ValidateConfigFileData() {
        // validate the configurations
        if (PreferredNeighbourCount < 1 || UnchockingInterval < 1 || OptimisticUnchokingInterval < 1 || FileSize < 1
                || PieceSize < 1) {

            System.out.println("One of the configuration is file \"" + ConfigFileName + "\" is incorrect.");
            return false;
        }

        if (CheckFileIsMissing(FileName)) {

            System.out.println("The file: \"" + FileName + "\" specified in the configuration does not exists.");
            return false;
        }

        try {
            DatFile = new RandomAccessFile(new java.io.File(FileName), "rw");
        } catch (FileNotFoundException ex) {

            System.out.println("Failed to open data file for IO.");
            return false;
        }
        /*
         * if (Files.size(Paths.get(FileName)) != FileSize){
         * 
         * System.out.println
         * ("The file size specified in configuration and size of actual file does not match."
         * ); return false; }
         */

        return true;
    }

    private boolean ReadConfigFile() {
        Scanner fileScanner;
        String configLabel;

        try {
            fileScanner = new Scanner(Paths.get(ConfigFileName));

            while (fileScanner.hasNext()) {

                configLabel = fileScanner.next();

                // updating the relevant configuration based on the config label
                switch (configLabel) {
                case "NumberOfPreferredNeighbors":
                    PreferredNeighbourCount = fileScanner.nextInt();
                    break;

                case "UnchokingInterval":
                    UnchockingInterval = fileScanner.nextInt() * 1000;
                    LastChokeUpdateTime = -1 * UnchockingInterval;
                    break;

                case "OptimisticUnchokingInterval":
                    OptimisticUnchokingInterval = fileScanner.nextInt() * 1000;
                    LastOptimisticUnchokingIntervalUpdateTime = OptimisticUnchokingInterval * -1;
                    break;

                case "FileName":
                    FileName = fileScanner.next();
                    break;

                case "FileSize":
                    FileSize = fileScanner.nextInt();
                    break;

                case "PieceSize":
                    PieceSize = fileScanner.nextInt();
                    break;

                default:
                    System.out.println("Invalid configuration value: " + configLabel);
                    return false;
                }
            }
        } catch (IOException ex) {
            System.out.println("Unable to open configuration file : \"" + ConfigFileName + "\".");
            System.out.println(ex.getMessage());
            return false;
        }

        return ValidateConfigFileData();
    }

    private boolean ReadPeerFile() {

        try {

            Scanner fileScanner = new Scanner(Paths.get(PeerInfoFile));

            while (fileScanner.hasNext()) {

                int arraySize;
                int pktCount;
                int lastblockval = 0;

                PeerConfigurationData peerData;

                peerData = new PeerConfigurationData();

                peerData.PeerId = fileScanner.nextInt();
                peerData.HostName = fileScanner.next();
                peerData.PortNumber = fileScanner.nextInt();
                peerData.HasFile = (fileScanner.nextInt() == 1);

                // the application assumes the client to be un-interested until explicitly
                // informed
                if (peerData.PeerId != MyPeerId)
                    peerData.IsInterested.set(true);

                // by default the client is choked until determined otherwise
                peerData.IsChocked.set(true);

                // no choke info is sent by default
                peerData.SendChokeInfo.set(false);

                pktCount = FileSize / PieceSize + ((FileSize % PieceSize > 0) ? 1 : 0);

                if (pktCount % BitPerBufVal > 0) {

                    // set the last few bits of the last block if they are not present in file it
                    // will prevent us from repeated checking if we have reached beyond the end
                    for (int iter = BitPerBufVal - pktCount % BitPerBufVal; iter > 0; iter--)
                        lastblockval = (lastblockval << 1) + 1;

                    arraySize = pktCount / BitPerBufVal + 1;
                } else {
                    arraySize = pktCount / BitPerBufVal;
                }

                if (peerData.PeerId == MyPeerId && !peerData.HasFile)
                    DatFile.setLength(0);

                if (peerData.PeerId == MyPeerId && peerData.HasFile) {
                    peerData.NumPiecesAvailable = pktCount;
                } else
                    peerData.NumPiecesAvailable = 0;

                peerData.FileState = new AtomicIntegerArray(arraySize);
                peerData.RequestedFileState = new AtomicIntegerArray(arraySize);

                for (int iter = 0; iter < arraySize; iter++) {

                    // if the application has full file it will initialize its file state as all bit
                    // set to 1
                    if (peerData.PeerId == MyPeerId && peerData.HasFile) {
                        peerData.FileState.set(iter, -1);
                        peerData.HasFullFile = true;
                    } else {// the value is yer to be discovered by the application protocol

                        peerData.FileState.set(iter, (iter + 1 == arraySize) ? lastblockval : 0);
                        peerData.HasFullFile = false;
                    }
                }

                // adding the peer information to a list fou later use
                PeerMap.put(peerData.PeerId, peerData);
            }
        } catch (IOException ex) {
            System.out.println("Unable to open the configuration file: \"" + PeerInfoFile + "\".");
            System.out.println(ex.getMessage());
            return false;
        }

        return true;
    }

    /**
     * Reads both the configuration files and populates the app variables.
     *
     * @return true when the configurations are successfully read and false
     *         otherwise.
     */
    private boolean ReadConfigurations() {

        if (CheckFileIsMissing(ConfigFileName))
            return false;

        if (CheckFileIsMissing(PeerInfoFile))
            return false;

        return ReadConfigFile() && ReadPeerFile();
    }

    public static void main(String[] args) {

        peerProcess myApp = new peerProcess(Integer.parseInt(args[0]));

        if (!myApp.Initialize())
            return;

        // the application can go multithreaded beyond this point
        myApp.Execute();

        myApp.CleanUp();
    }

    private void CleanUp() {
        Logger.GetLogger().Log("Program termination time: "
                + new SimpleDateFormat("mm/dd/yyyy HH:mm:ss").format((Calendar.getInstance().getTime())));
        Logger.GetLogger().Close();
    }

    /**
     * The function checks if all the peers have got the full file
     *
     * @return true if all peers have full file, else false
     */
    private boolean AllPeersHaveFile() {

        for (Map.Entry<Integer, PeerConfigurationData> mapPair : PeerMap.entrySet()) {

            // if any of the peer does not have full file return false
            for (int iter = mapPair.getValue().FileState.length() - 1; iter >= 0; iter--) {
                if (mapPair.getValue().FileState.get(iter) != -1)
                    return false;
            }
        }

        return true;
    }

    private boolean ConnectToKnownHosts() {
        Iterator iter = PeerMap.entrySet().iterator();
        Socket newSocket;
        Thread newThread;

        while (iter.hasNext()) {

            Map.Entry mapPair = (Map.Entry) iter.next();

            // the other socket after this are responsible for initiating connect to this
            // instance
            if (((PeerConfigurationData) mapPair.getValue()).PeerId == MyPeerId)
                break;

            try {
                newSocket = new Socket(InetAddress.getByName(((PeerConfigurationData) mapPair.getValue()).HostName),
                        ((PeerConfigurationData) mapPair.getValue()).PortNumber);

                newThread = new AppController(newSocket, MyPeerId, true, HaveBroadCastList);

                // thread is marked as daemon. Only the main thread is non daemon. But is
                // blocked for all task to complete. If all task is complete we quit :)
                newThread.setDaemon(true);

                newThread.start();
            } catch (IOException ex) {
                System.out.println("*******************EXCEPTION*******************");
                System.out.println("IOException occurred while creating socket.");
                System.out.println(ex.getMessage());
            }

        }

        return true;
    }

    private void DoUnChokedNodeReselection() {
        class QueueData {
            int Val;
            private PeerConfigurationData Peer;
        }

        class QueueComparator implements Comparator<QueueData> {
            public int compare(QueueData pVal1, QueueData pVal2) {
                return pVal1.Val - pVal2.Val;
            }
        }

        Comparator<QueueData> comparator = new QueueComparator();

        PriorityQueue<QueueData> interestedPeers = new PriorityQueue<>(10, comparator);
        QueueData temp;
        int lastVal = Integer.MAX_VALUE;

        // getting all interested peers
        for (Map.Entry<Integer, PeerConfigurationData> mapPair : PeerMap.entrySet()) {

            if (mapPair.getValue().IsInterested.get() && mapPair.getValue().PeerId != OptUnchokedPeerId
                    && mapPair.getValue().PeerId != MyPeerId) {

                QueueData data = new QueueData();

                data.Val = mapPair.getValue().ReceivedPiecesCount.get();
                data.Peer = mapPair.getValue();

                interestedPeers.add(data);

            } else {

                // we have not interested companions here its better to choke them if they are
                // not already chocked
                if (!mapPair.getValue().IsChocked.get()) {

                    mapPair.getValue().IsChocked.set(true);
                    // its our responsibility to inform them
                    mapPair.getValue().SendChokeInfo.set(true);
                }
            }
        }

        if (interestedPeers.size() > 1) {

            int count = PreferredNeighbourCount;

            while (count > 0 && interestedPeers.size() > 1) {
                count--;

                temp = interestedPeers.peek();

                if (InDebug) {

                    if (lastVal < temp.Val) {
                        System.out.println("Bug in Preferred neighbour selection.");
                    }

                    lastVal = temp.Val;
                }

                if (temp.Peer.IsChocked.get()) {
                    temp.Peer.IsChocked.set(false);
                    temp.Peer.SendChokeInfo.set(true);
                }

                temp.Peer.ReceivedPiecesCount.set(0);

                interestedPeers.remove(temp);
            }
        }

        // mark all the remaining as chocked
        while (interestedPeers.size() > 1) {
            temp = interestedPeers.peek();

            if (InDebug) {
                if (lastVal < temp.Val) {
                    System.out.println("Bug in Preferred neighbour selection.");
                }
                lastVal = temp.Val;
            }

            if (!temp.Peer.IsChocked.get()) {

                // as the peer was not selected choke the same and inform
                temp.Peer.IsChocked.set(true);
                temp.Peer.SendChokeInfo.set(true);
            }

            interestedPeers.remove(temp);
        }
    }

    private void SelectOptimisticNode() {
        int randomPos;
        Set<Integer> keySet;
        PeerConfigurationData peer;
        int retryCount = 0;

        if (OptUnchokedPeerId > 0)
            PeerMap.get(OptUnchokedPeerId).IsChocked.set(true);

        while (true) {

            retryCount++;

            randomPos = (int) Math.random() * PeerMap.size();

            keySet = PeerMap.keySet();

            peer = PeerMap.get(keySet.toArray()[randomPos]);

            // cannot select only interested and chocked neighbours
            // note : the retry count is provided in case all the nodes are un-chocked due
            // to defined configurations
            if (peer.IsInterested.get() && !peer.IsChocked.get() && peer.PeerId != MyPeerId)
                break;
            else if (retryCount > PeerMap.size()) {
                peer = null;
                break;
            }
        }

        // TODO Do something with the selected peer
        if (peer != null) {

            if (peer.PeerId != OptUnchokedPeerId) {
                OptUnchokedPeerId = peer.PeerId;
                peer.SendChokeInfo.set(true);
            }

            peer.IsChocked.set(false);

        } else
            OptUnchokedPeerId = -1;
    }

    private void MakeChokeRelatedAmends() {

        if (LastChokeUpdateTime - Calendar.getInstance().getTimeInMillis() >= UnchockingInterval)
            DoUnChokedNodeReselection();

        if (LastOptimisticUnchokingIntervalUpdateTime
                - Calendar.getInstance().getTimeInMillis() >= OptimisticUnchokingInterval)
            SelectOptimisticNode();
    }

    /**
     * Initiates all the helping threads needed by the application
     *
     * <p>
     * To keep the wait time on the server thread minimum we are spawning other
     * threads to perform other routine maintenance work
     * </p>
     */
    private void InitiateCompletionWait() {
        while (true) {

            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                System.out.println("*******************EXCEPTION*******************");
                System.out.println("IOException occurred while checking for task completion.");
                System.out.println(ex.getMessage());
            }

            if (AllPeersHaveFile()) {
                TaskComplete.set(true);
                break;
            }

            MakeChokeRelatedAmends();
        }
    }

    /**
     * The actual operations starts here
     */
    private void Execute() {
        Runnable listenerTask;
        Thread listenerThread;

        listenerTask = new Runnable() {

            public void run() {
                Thread noob;

                try {
                    ServerSocket listeningSocket;
                    listeningSocket = new ServerSocket(PeerMap.get(MyPeerId).PortNumber);

                    // the server would keep listening
                    while (!TaskComplete.get()) {

                        noob = new AppController(listeningSocket.accept(), MyPeerId, false, HaveBroadCastList);

                        noob.setDaemon(true);

                        noob.start();
                    }
                } catch (IOException ex) {
                    System.out.println("*******************EXCEPTION*******************");
                    System.out.println("IOException occurred while closing a connection.");
                    System.out.println(ex.getMessage());
                }
            }
        };

        listenerThread = new Thread(listenerTask, "peerProcessListner");

        // listener thread is marked as daemon as if the main thread exits all task is
        // complete so all threads except main thread are marked daemon
        listenerThread.setDaemon(true);

        listenerThread.start();

        if (!ConnectToKnownHosts())
            return;

        // wait till the task is actually completed i.e all peers have full file
        InitiateCompletionWait();
    }
}
